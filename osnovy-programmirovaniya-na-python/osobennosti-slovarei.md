# Особенности словарей

### **1. Основные особенности словарей**

1. **Ключи уникальны**
   * В словаре **не может быть одинаковых ключей**. Если добавить ключ, который уже существует, его значение обновится:

```python
d = {"a": 1, "b": 2}
d["a"] = 10
print(d)  # {'a': 10, 'b': 2}
```

2. **Ключи неизменяемы**
   * Ключи могут быть **числа, строки, кортежи**, но не **списки или словари**:

```python
d = {(1, 2): "tuple"}  # допустимо
# d[[1, 2]] = "list"   # TypeError
```

3. **Неупорядоченность до Python 3.6**
   * До Python 3.6 словари **не гарантировали порядок элементов**.
   * Начиная с Python 3.7, словари **сохраняют порядок добавления элементов**.
4. **Быстрый доступ по ключу**
   * Доступ к элементу по ключу происходит **за O(1)**, что быстрее, чем поиск в списке.
5. **Значения могут быть любыми**
   * В словарь можно хранить **числа, строки, списки, кортежи, другие словари, объекты**:

```python
d = {"num": 10, "list": [1,2], "dict": {"a": 1}}
```

6. **Методы для безопасной работы**
   * `get()` — безопасное получение значения
   * `setdefault()` — добавляет ключ только если его нет
   * `pop()` и `popitem()` — удаление с возвратом значения

***

### **2. Примеры использования в автотестах**

#### **2.1 Обработка JSON/API**

```python
response = {"status": "ok", "data": {"id": 1, "name": "Alice"}}
assert response.get("status") == "ok"
```

#### **2.2 Хранение сложных данных**

```python
users = {
    "user1": {"password": "123", "active": True},
    "user2": {"password": "456", "active": False}
}
assert users["user1"]["active"] is True
```

#### **2.3 Фильтрация данных**

```python
users = [{"name": "Alice", "active": True}, {"name": "Bob", "active": False}]
active_users = [u for u in users if u.get("active")]
print(active_users)  # [{'name': 'Alice', 'active': True}]
```
